var Engine;(()=>{"use strict";var t,e={d:(t,s)=>{for(var i in s)e.o(s,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:s[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},s={};e.d(s,{default:()=>a}),function(t){t[t.a8=0]="a8",t[t.b8=1]="b8",t[t.c8=2]="c8",t[t.d8=3]="d8",t[t.e8=4]="e8",t[t.f8=5]="f8",t[t.g8=6]="g8",t[t.h8=7]="h8",t[t.a7=8]="a7",t[t.b7=9]="b7",t[t.c7=10]="c7",t[t.d7=11]="d7",t[t.e7=12]="e7",t[t.f7=13]="f7",t[t.g7=14]="g7",t[t.h7=15]="h7",t[t.a6=16]="a6",t[t.b6=17]="b6",t[t.c6=18]="c6",t[t.d6=19]="d6",t[t.e6=20]="e6",t[t.f6=21]="f6",t[t.g6=22]="g6",t[t.h6=23]="h6",t[t.a5=24]="a5",t[t.b5=25]="b5",t[t.c5=26]="c5",t[t.d5=27]="d5",t[t.e5=28]="e5",t[t.f5=29]="f5",t[t.g5=30]="g5",t[t.h5=31]="h5",t[t.a4=32]="a4",t[t.b4=33]="b4",t[t.c4=34]="c4",t[t.d4=35]="d4",t[t.e4=36]="e4",t[t.f4=37]="f4",t[t.g4=38]="g4",t[t.h4=39]="h4",t[t.a3=40]="a3",t[t.b3=41]="b3",t[t.c3=42]="c3",t[t.d3=43]="d3",t[t.e3=44]="e3",t[t.f3=45]="f3",t[t.g3=46]="g3",t[t.h3=47]="h3",t[t.a2=48]="a2",t[t.b2=49]="b2",t[t.c2=50]="c2",t[t.d2=51]="d2",t[t.e2=52]="e2",t[t.f2=53]="f2",t[t.g2=54]="g2",t[t.h2=55]="h2",t[t.a1=56]="a1",t[t.b1=57]="b1",t[t.c1=58]="c1",t[t.d1=59]="d1",t[t.e1=60]="e1",t[t.f1=61]="f1",t[t.g1=62]="g1",t[t.h1=63]="h1",t[t.no_sq=64]="no_sq"}(t||(t={}));class i{constructor(){this.name="KhepriChess",this.version="4.0.0",this.author="Kurt Peters",this.isChess960=!1,this.SquareBigInt=[0n,1n,2n,3n,4n,5n,6n,7n,8n,9n,10n,11n,12n,13n,14n,15n,16n,17n,18n,19n,20n,21n,22n,23n,24n,25n,26n,27n,28n,29n,30n,31n,32n,33n,34n,35n,36n,37n,38n,39n,40n,41n,42n,43n,44n,45n,46n,47n,48n,49n,50n,51n,52n,53n,54n,55n,56n,57n,58n,59n,60n,61n,62n,63n,64n],this.CharToPiece=new Map([["P",{Type:0,Color:0}],["N",{Type:1,Color:0}],["B",{Type:2,Color:0}],["R",{Type:3,Color:0}],["Q",{Type:4,Color:0}],["K",{Type:5,Color:0}],["p",{Type:0,Color:1}],["n",{Type:1,Color:1}],["b",{Type:2,Color:1}],["r",{Type:3,Color:1}],["q",{Type:4,Color:1}],["k",{Type:5,Color:1}]]),this.PieceToChar=new Map([[0,"P"],[1,"N"],[2,"B"],[3,"R"],[4,"Q"],[5,"K"]]),this.Zobrist={Pieces:Array.from(Array(2),(()=>Array.from(Array(6),(()=>new Array(64))))),EnPassant:new BigUint64Array(64),Castle:new BigUint64Array(16),SideToMove:0n},this.PhaseValues=[0,1,1,2,4,0],this.PhaseTotal=4*this.PhaseValues[1]+4*this.PhaseValues[2]+4*this.PhaseValues[3]+2*this.PhaseValues[4],this.BoardHistory=[],this.BoardState={PiecesBB:new BigUint64Array(12),OccupanciesBB:new BigUint64Array(2),Squares:new Array(64).fill(void 0),SideToMove:0,EnPassSq:t.no_sq,HalfMoves:0,Ply:0,Hash:0n,PawnHash:0n,Phase:this.PhaseTotal,CastlingRights:0,CastlingPaths:[],CastlingRookSquares:[],CastlingSquaresMask:new Array(64).fill(15)},this.rankMasks=new BigUint64Array(64),this.fileMasks=new BigUint64Array(64),this.isolatedMasks=new BigUint64Array(64),this.passedMasks=Array(2).fill(0).map((()=>Array(64).fill(0))),this.betweenMasks=Array(64).fill(0n).map((()=>Array(64).fill(0n))),this.attackRays=Array.from(Array(3),(()=>new Array(64).fill(0n))),this.squareBB=new BigUint64Array(64),this.distanceBetween=Array(64).fill(0n).map((()=>Array(64).fill(0n))),this.notAFile=18374403900871474942n,this.notHFile=9187201950435737471n,this.notHGFile=4557430888798830399n,this.notABFile=18229723555195321596n,this.PawnAttacks=new BigUint64Array(128),this.KnightAttacks=new BigUint64Array(64),this.KingAttacks=new BigUint64Array(64),this.BishopMasks=new BigUint64Array(64),this.BishopAttacks=Array.from(Array(64),(()=>new Array(512))),this.RookMasks=new BigUint64Array(64),this.RookAttacks=Array.from(Array(64),(()=>new Array(4096))),this.BishopMagicNumbers=[0x2004200884050840n,0x410100220842020n,0x4008108408800844n,0x4188204040844200n,0x2044030841204080n,0x5008229010048001n,0x48809008228000n,0xa00210050100800n,0x40121020020c006an,0x1441004012828n,0x5188202420508n,0x1106404208c00a1n,0x2820884841010000n,0x1800020802480841n,0x48440048041008c0n,0x128c1a020686a800n,0x4808011191100080n,0x885402008208102n,0x204000818002008n,0x28000c204010a0n,0x204a000404a20020n,0x4001000020a01000n,0x9008912044100888n,0x5603c082090901n,0x6620700048230800n,0x18100d00820c1c02n,0x49222002c040403n,0x20808088020002n,0x4038c000280201an,0x2080836809011n,0x102008432280100n,0x201c302011280n,0x121008040122c400n,0x104014801200211n,0x3800223400080800n,0x14020080480080n,0x2004040400001010n,0xd0510040460041n,0x1180082010460n,0x4208c0040370504n,0x12010440002200n,0x40104208440020a0n,0x1d0c0048001404n,0x804204010452200n,0xa08102010401208n,0x230115001002020n,0x2008028082040402n,0x408080060480380n,0x1010802402080n,0x403088090086800n,0x20a0020201041000n,0x200a8042420e0800n,0x8004008a1010400n,0x910230010004n,0xc0100200811040n,0x2202102307050410n,0x20208200904000n,0x4002104100411n,0x8010000044040490n,0xa0008040840400n,0x1006001110121201n,0xc00c4088017108n,0x2800080210020210n,0x60200a1002018910n],this.RookMagicNumbers=[0x80016418400081n,0x40004010002000n,0x48020011000800an,0xc800c8290000800n,0x200080420020010n,0x8100020400080100n,0x8080008002000100n,0xe10000c600288100n,0x800080304000n,0xa00210a004081n,0xb0080200010008an,0x8808008001000n,0x1004808004000800n,0x92000600508c08n,0x100400040102d018n,0x8004e9000a80n,0x21b4228000400082n,0x41010020804000n,0x208c110020090040n,0x2030010020081100n,0x300808008000400n,0x9202008080040002n,0x400804000201b008n,0x1060020004008041n,0x36846080034000n,0x208040008020008cn,0x200080100080n,0x2088100080080080n,0x1800808004000an,0x812040080020080n,0x8041010400100802n,0x904a482000c00c3n,0x40204000800080n,0x40201008400041n,0xa10040800200020n,0x380801004800800n,0x804000800800480n,0x184800200800400n,0x1002100104004882n,0x240186000943n,0x100802040188000n,0x890004020004000n,0x4810080400202000n,0x2c00100008008080n,0x8000805010010n,0x200c010002004040n,0x1001c21011340048n,0x4084146081020004n,0x102002080410200n,0xa004088210200n,0x804200281200n,0x100008008080n,0x110a080081040080n,0x4010002004040n,0x400c08294a100400n,0x12441080410a00n,0x608880f1020240a2n,0x108025004202n,0xa4c401020000d01n,0x19000410000821n,0x4052009120080402n,0x2000884011002n,0x20c100104b2080cn,0xc04104100840022n],this.BishopRelevantBits=[6n,5n,5n,5n,5n,5n,5n,6n,5n,5n,5n,5n,5n,5n,5n,5n,5n,5n,7n,7n,7n,7n,5n,5n,5n,5n,7n,9n,9n,7n,5n,5n,5n,5n,7n,9n,9n,7n,5n,5n,5n,5n,7n,7n,7n,7n,5n,5n,5n,5n,5n,5n,5n,5n,5n,5n,6n,5n,5n,5n,5n,5n,5n,6n],this.RookRelevantBits=[12n,11n,11n,11n,11n,11n,11n,12n,11n,10n,10n,10n,10n,10n,10n,11n,11n,10n,10n,10n,10n,10n,10n,11n,11n,10n,10n,10n,10n,10n,10n,11n,11n,10n,10n,10n,10n,10n,10n,11n,11n,10n,10n,10n,10n,10n,10n,11n,11n,10n,10n,10n,10n,10n,10n,11n,12n,11n,11n,11n,11n,11n,11n,12n],this.PRNG_SEED=192085716n,this.boardStates=[],this.TranspositionTables=Array(2097152).fill(null),this.TTSize=BigInt(2097152),this.TTUsed=0,this.PawnTable=Array(262144).fill(null),this.PawnTableSize=BigInt(262144),this.PST=[[[0,0,0,0,0,0,0,0,43,42,29,35,18,19,2,17,-9,1,-2,21,3,49,16,-10,-24,-22,-21,-6,3,-13,-10,-19,-29,-25,-21,-5,-9,-7,15,-14,-31,-27,-26,-20,-16,-12,44,-1,-35,-30,-36,-34,-32,9,54,-9,0,0,0,0,0,0,0,0],[-39,-4,-4,-5,6,-4,1,-29,-24,-13,10,30,33,37,-14,3,-13,12,17,46,43,75,34,13,-6,-4,12,27,0,48,2,33,-17,3,7,-1,9,9,-1,-15,-27,-14,-6,-8,3,-9,10,-37,-30,-26,-24,-9,-8,-15,-13,-8,-20,-18,-30,-34,-23,-16,-23,-28],[-12,-15,-8,-4,-9,-6,-1,-5,-16,-5,7,-3,10,0,-5,-3,-4,2,14,26,26,80,36,36,-21,-14,7,25,14,-6,-9,-4,-9,2,-8,24,11,-1,-7,-17,-10,0,-2,-7,-3,0,5,1,-26,-7,2,-10,-12,-3,14,12,-21,-7,-14,-28,-13,-30,-10,-20],[3,-1,8,25,21,20,16,19,-32,-22,0,19,20,31,36,18,-35,-20,-11,2,25,30,13,7,-33,-32,-25,-3,-6,6,11,-6,-36,-33,-43,-17,-8,-8,14,-25,-46,-31,-37,-25,-31,-29,9,-23,-29,-42,-31,-26,-16,7,-13,-33,-20,-35,-33,-24,-20,-10,-50,-10],[-35,-8,4,13,27,25,21,28,-31,-19,-8,12,14,67,54,49,-21,-13,-16,21,46,69,71,37,-18,-12,-8,1,7,18,3,-1,-10,-9,-19,-17,-11,-4,6,-13,-30,-1,-14,-13,-19,-13,5,-13,-31,-15,-13,-2,-2,-3,-18,-26,-18,-34,-30,1,-19,-32,-18,-9],[-1,1,0,2,0,2,1,-1,-1,3,4,2,5,5,6,2,0,2,4,6,8,11,9,5,-2,1,4,1,2,6,-1,-3,-1,1,-4,-4,3,-17,-17,-32,-3,-7,-11,-21,-21,-16,-21,-24,-5,-2,-8,-50,-32,-56,33,53,-7,-22,-4,-52,32,-50,61,53]],[[0,0,0,0,0,0,0,0,69,70,60,35,40,40,55,67,43,45,25,-16,4,4,38,39,12,-2,-16,-42,-34,-22,-10,-7,-3,-13,-25,-38,-35,-30,-25,-29,-15,-18,-26,-25,-26,-23,-40,-34,-1,-5,-8,-50,-16,-10,-23,-29,0,0,0,0,0,0,0,0],[-30,-5,-4,-2,3,-1,0,-19,-21,-6,17,26,13,-1,-13,-16,-15,12,30,30,30,19,-3,-14,-7,9,31,47,37,23,22,-9,-9,0,36,29,37,15,1,-5,-30,-3,10,22,13,10,-18,-17,-14,-8,-9,9,-12,-10,-12,-14,-18,-69,-26,-8,-12,-16,-49,-26],[-6,-14,-1,1,2,3,7,-6,2,4,0,4,6,13,2,-26,-5,11,15,-3,20,37,18,3,-6,25,20,33,22,24,16,-8,-7,-2,38,27,22,12,-5,-20,-23,3,26,22,27,11,-12,-13,-20,-31,-15,1,3,-8,-11,-19,-20,-34,-50,-11,-23,-35,-8,-21],[10,21,21,20,23,24,24,26,29,31,28,26,19,9,22,9,27,19,20,10,6,15,23,9,14,17,22,8,-6,13,4,-4,-4,1,21,5,-10,-8,-5,-18,-8,-14,1,-6,-11,-11,-21,-29,-23,-27,-12,-16,-21,-32,-15,-27,-15,-2,6,-1,-7,-14,-7,-72],[-13,3,15,11,21,27,11,19,-22,-9,10,10,30,39,29,11,-31,-15,-5,4,36,50,36,13,-27,-8,2,25,32,33,25,16,-39,-10,1,46,21,18,4,13,-17,-36,2,-2,21,10,3,-8,-16,-13,-17,-33,-28,-26,-12,-11,-20,-22,-18,-65,-16,-28,-16,-7],[-17,-5,-1,-1,1,8,4,-8,-6,16,18,10,19,27,31,4,3,26,25,27,33,47,41,21,-12,27,26,30,29,45,34,4,-17,-6,15,19,21,19,12,-20,-19,-6,4,11,11,3,-8,-20,-20,-13,-14,0,1,5,-20,-44,-19,-29,-17,-20,-85,-26,-57,-79]]],this.MGPieceValue=[69,260,270,352,905,15e3],this.EGPieceValue=[122,287,322,548,947,15e3],this.MGKnightOutpost=7,this.EGKnightOutpost=16,this.MGRookOpenFileBonus=40,this.MGRookSemiOpenFileBonus=18,this.MGBishopPair=5,this.EGBishopPair=53,this.PawnDuoMulti=[0,-5,10,32,78,44,27],this.PawnSupportMulti=[0,0,22,17,25,43,31],this.MGDoubledPawn=17,this.EGDoubledPawn=17,this.MGIsolatedPawn=9,this.EGIsolatedPawn=0,this.MGPassedPawnRank=[0,7,-3,-17,8,26,70],this.EGPassedPawnRank=[0,-2,10,43,64,82,90],this.MGCorneredBishopPenalty=3,this.EGCorneredBishopPenalty=55,this.CenterDistance=[3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,3,3,2,1,1,1,1,2,3,3,2,1,0,0,1,2,3,3,2,1,0,0,1,2,3,3,2,1,1,1,1,2,3,3,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3],this.CenterManhattanDistance=[6,5,4,3,3,4,5,6,5,4,3,2,2,3,4,5,4,3,2,1,1,2,3,4,3,2,1,0,0,1,2,3,3,2,1,0,0,1,2,3,4,3,2,1,1,2,3,4,5,4,3,2,2,3,4,5,6,5,4,3,3,4,5,6],this.INFINITY=6e4,this.MATE=3e4,this.MAXPLY=100,this.ABORTEDSCORE=5e5,this.nodesSearched=0,this.pvArray=Array(this.MAXPLY).fill(0).map((()=>Array(this.MAXPLY).fill(0))),this.pvLength=Array(this.MAXPLY).fill(0),this.killerMoves=Array(this.MAXPLY).fill(0).map((()=>Array(2).fill(0))),this.historyMoves=Array(2).fill(0).map((()=>Array(64).fill(0).map((()=>Array(64).fill(0))))),this.counterMoves=Array(64).fill(0).map((()=>Array(64).fill(0))),this.bestMoveScore={move:0,score:-this.INFINITY},this.Timer={timeleft:-1,increment:0,depth:this.MAXPLY,movestogo:0,startTime:0,stopTime:0,movetime:-1,stop:!1,extended:!1},this.totalNodes=0,this.Init(),this.InitHashes()}Reset(){this.BoardHistory.length=0,this.BoardState.PiecesBB=new BigUint64Array(12),this.BoardState.OccupanciesBB=new BigUint64Array(2),this.BoardState.Squares=new Array(64).fill(void 0),this.BoardState.SideToMove=0,this.BoardState.EnPassSq=t.no_sq,this.BoardState.HalfMoves=0,this.BoardState.Ply=0,this.BoardState.PawnHash=0n,this.BoardState.Phase=this.PhaseTotal,this.BoardState.CastlingRights=0,this.BoardState.CastlingPaths=[],this.BoardState.CastlingRookSquares=[],this.BoardState.CastlingSquaresMask=new Array(64).fill(15),this.TranspositionTables=Array(2097152).fill(null),this.TTSize=BigInt(2097152),this.TTUsed=0,this.PawnTable=Array(262144).fill(null),this.PawnTableSize=BigInt(262144),this.nodesSearched=0,this.pvArray=Array(this.MAXPLY).fill(0).map((()=>Array(this.MAXPLY).fill(0))),this.pvLength=Array(this.MAXPLY).fill(0),this.killerMoves=Array(this.MAXPLY).fill(0).map((()=>Array(2).fill(0))),this.historyMoves=Array(2).fill(0).map((()=>Array(64).fill(0).map((()=>Array(64).fill(0))))),this.counterMoves=Array(64).fill(0).map((()=>Array(64).fill(0)))}Random64(){let t=this.PRNG_SEED;return t^=t>>12n,t^=BigInt.asUintN(64,t<<25n),t^=t>>27n,this.PRNG_SEED=t,BigInt.asUintN(64,2685821657736338717n*t)}FindMagics(e){const s=new BigUint64Array(4096),i=new BigUint64Array(4096),a=2===e;for(let e=t.a8;e<=t.h1;e++){let t=0n;const o=a?this.GenerateBishopMasks(e):this.GenerateRookMasks(e),n=a?this.BishopRelevantBits[e]:this.RookRelevantBits[e],h=Number(this.CountBits(o));for(let t=0;t<1<<h;t++)s[t]=this.SetOccupancy(t,h,o),i[t]=a?this.GenerateBishopAttacksFly(e,s[t]):this.GenerateRookAttacksFly(e,s[t]);for(;;){if(t=BigInt.asUintN(64,this.Random64()&this.Random64()&this.Random64()),this.CountBits(0xff00000000000000n&BigInt.asUintN(64,o*t))<6)continue;const a=new BigUint64Array(4096);let r=!1;for(let e=0;e<1<<h;e++){const o=Number(BigInt.asUintN(64,s[e]*t)>>64n-n);if(0n===a[o])a[o]=i[e];else if(a[o]!==i[e]){r=!0;break}}if(!r){console.log(`Square: ${e} magic: 0x${t.toString(16)}`);break}}}}SetBit(t,e){return t|1n<<this.SquareBigInt[e]}RemoveBit(t,e){return t&~(1n<<this.SquareBigInt[e])}GetBit(t,e){return t&1n<<this.SquareBigInt[e]}CountBits(t){const e=Number(0xffffffffn&t),s=Number(t>>32n);function i(t){return 16843009*((t=(858993459&(t-=t>>1&1431655765))+(t>>2&858993459))+(t>>4)&252645135)>>24}return i(e)+i(s)}GetLS1B(t){return this.CountBits((t&-t)-1n)}SetOccupancy(t,e,s){let i=0n;for(let a=0;a<e;a++){const e=this.GetLS1B(s);s=this.RemoveBit(s,e),t&1<<a&&(i|=1n<<this.SquareBigInt[e])}return BigInt.asUintN(64,i)}Shift(t,e){switch(e){case 8:return t>>8n;case-8:return BigInt.asUintN(64,t<<8n);case 1:return(t&this.notHFile)<<1n;case-1:return(t&this.notAFile)>>1n;case 9:return(t&this.notAFile)>>9n;case 7:return(t&this.notHFile)>>7n;case-9:return(t&this.notHFile)<<9n;case-7:return(t&this.notAFile)<<7n}}Fill(t,e){let s=this.squareBB[e];return 8===t?(s|=s>>8n,s|=s>>16n,s|=s>>32n):(s|=s<<8n,s|=s<<16n,s|=s<<32n),this.Shift(s,t)}Init(){const e=-1n,s=0x0001010101010100n,i=0x0040201008040200n,a=0x0002040810204080n;let o,n,h,r;for(let B=t.a8;B<=t.h1;B++){this.squareBB[B]=this.SetBit(0n,B),this.rankMasks[B]=0xffn<<(56n&BigInt(B)),this.fileMasks[B]=0x0101010101010101n<<(7n&BigInt(B)),this.isolatedMasks[B]=(this.fileMasks[B]&this.notHFile)<<1n|(this.fileMasks[B]&this.notAFile)>>1n,this.PawnAttacks[B]=this.MaskPawnAttacks(0,B),this.PawnAttacks[B+64]=this.MaskPawnAttacks(1,B),this.KnightAttacks[B]=this.MaskKnightAttacks(B),this.KingAttacks[B]=this.MaskKingAttacks(B),this.BishopMasks[B]=this.GenerateBishopMasks(B);let t=this.CountBits(this.BishopMasks[B]),l=1<<t;for(let e=0;e<l;e++){const s=this.SetOccupancy(e,t,this.BishopMasks[B]),i=BigInt.asUintN(64,s*this.BishopMagicNumbers[B])>>64n-this.BishopRelevantBits[B];this.BishopAttacks[B][Number(i)]=this.GenerateBishopAttacksFly(B,s)}this.RookMasks[B]=this.GenerateRookMasks(B),t=this.CountBits(this.RookMasks[B]),l=1<<t;for(let e=0;e<l;e++){const s=this.SetOccupancy(e,t,this.RookMasks[B]),i=BigInt.asUintN(64,s*this.RookMagicNumbers[B])>>64n-this.RookRelevantBits[B];this.RookAttacks[B][Number(i)]=this.GenerateRookAttacksFly(B,s)}this.attackRays[0][B]=this.GenerateBishopAttacks(0n,B),this.attackRays[2][B]|=this.attackRays[0][B],this.attackRays[1][B]=this.GenerateRookAttacks(0n,B),this.attackRays[2][B]|=this.attackRays[1][B];let c=this.fileMasks[B]|(this.fileMasks[B]&this.notAFile)>>1n|(this.fileMasks[B]&this.notHFile)<<1n;this.passedMasks[0][B]=c,this.passedMasks[1][56^B]=c;for(let t=0;t<64;t++){const l=B>>3,c=t>>3,S=7&B,d=7&t;this.distanceBetween[B][t]=Math.max(Math.abs(c-l),Math.abs(d-S)),o=e<<BigInt(B)^e<<BigInt(t),r=(7n&BigInt(t))-(7n&BigInt(B)),h=(7n|BigInt(t))-BigInt(B)>>3n,n=(7n&r)-1n&s,n+=2n*((7n&h)-1n>>58n),n+=(h-r&15n)-1n&i,n+=(h+r&15n)-1n&a,n*=o&-o,this.betweenMasks[B][t]=BigInt.asUintN(64,n&o)}}for(let e=t.a8;e<=t.h1;e++){for(let s=e;s<=t.h1;s+=8)this.passedMasks[0][e]&=~this.rankMasks[s];for(let s=e;s>=t.a8;s-=8)this.passedMasks[1][56^e]&=~this.rankMasks[s]}}InitHashes(){for(let e=0;e<=5;e++)for(let s=t.a8;s<=t.h1;s++)this.Zobrist.Pieces[0][e][s]=this.Random64(),this.Zobrist.Pieces[1][e][s]=this.Random64();for(let e=t.a8;e<=t.h1;e++)this.Zobrist.EnPassant[e]=this.Random64();for(let t=0;t<16;t++)this.Zobrist.Castle[t]=this.Random64();this.Zobrist.SideToMove=this.Random64()}GenerateHashes(){let e=0n,s=0n;for(let i=t.a8;i<=t.h1;i++){const t=this.BoardState.Squares[i];t&&(e^=this.Zobrist.Pieces[t.Color][t.Type][i],0===t.Type&&(s^=this.Zobrist.Pieces[t.Color][0][i]))}return this.BoardState.EnPassSq!==t.no_sq&&(e^=this.Zobrist.EnPassant[this.BoardState.EnPassSq]),e^=this.Zobrist.Castle[this.BoardState.CastlingRights],1===this.BoardState.SideToMove&&(e^=this.Zobrist.SideToMove),{hash:e,pawnHash:s}}MaskPawnAttacks(t,e){let s=0n,i=0n;return i=this.SetBit(i,e),t?(i<<7n&this.notHFile&&(s|=i<<7n),i<<9n&this.notAFile&&(s|=i<<9n)):(i>>7n&this.notAFile&&(s|=i>>7n),i>>9n&this.notHFile&&(s|=i>>9n)),BigInt.asUintN(64,s)}MaskKnightAttacks(t){let e=0n,s=0n;return s=this.SetBit(s,t),s>>17n&this.notHFile&&(e|=s>>17n),s>>15n&this.notAFile&&(e|=s>>15n),s>>10n&this.notHGFile&&(e|=s>>10n),s>>6n&this.notABFile&&(e|=s>>6n),s<<17n&this.notAFile&&(e|=s<<17n),s<<15n&this.notHFile&&(e|=s<<15n),s<<10n&this.notABFile&&(e|=s<<10n),s<<6n&this.notHGFile&&(e|=s<<6n),BigInt.asUintN(64,e)}MaskKingAttacks(t){let e=0n,s=0n;return s=this.SetBit(s,t),s>>8n&&(e|=s>>8n),s>>9n&this.notHFile&&(e|=s>>9n),s>>7n&this.notAFile&&(e|=s>>7n),s>>1n&this.notHFile&&(e|=s>>1n),s<<8n&&(e|=s<<8n),s<<9n&this.notAFile&&(e|=s<<9n),s<<7n&this.notHFile&&(e|=s<<7n),s<<1n&this.notAFile&&(e|=s<<1n),BigInt.asUintN(64,e)}GenerateBishopMasks(t){let e=0n;const s=Math.floor(t/8),i=t%8;for(let t=s+1,a=i+1;t<=6&&a<=6;t++,a++)e|=1n<<8n*BigInt(t)+BigInt(a);for(let t=s-1,a=i+1;t>=1&&a<=6;t--,a++)e|=1n<<8n*BigInt(t)+BigInt(a);for(let t=s+1,a=i-1;t<=6&&a>=1;t++,a--)e|=1n<<8n*BigInt(t)+BigInt(a);for(let t=s-1,a=i-1;t>=1&&a>=1;t--,a--)e|=1n<<8n*BigInt(t)+BigInt(a);return BigInt.asUintN(64,e)}GenerateBishopAttacksFly(t,e){let s=0n;const i=Math.floor(t/8),a=t%8;for(let t=i+1,o=a+1;t<=7&&o<=7&&(s|=1n<<8n*BigInt(t)+BigInt(o),!(1n<<8n*BigInt(t)+BigInt(o)&e));t++,o++);for(let t=i-1,o=a+1;t>=0&&o<=7&&(s|=1n<<8n*BigInt(t)+BigInt(o),!(1n<<8n*BigInt(t)+BigInt(o)&e));t--,o++);for(let t=i+1,o=a-1;t<=7&&o>=0&&(s|=1n<<8n*BigInt(t)+BigInt(o),!(1n<<8n*BigInt(t)+BigInt(o)&e));t++,o--);for(let t=i-1,o=a-1;t>=0&&o>=0&&(s|=1n<<8n*BigInt(t)+BigInt(o),!(1n<<8n*BigInt(t)+BigInt(o)&e));t--,o--);return BigInt.asUintN(64,s)}GenerateRookMasks(t){let e=0n;const s=Math.floor(t/8),i=t%8;for(let t=s+1;t<=6;t++)e|=1n<<8n*BigInt(t)+BigInt(i);for(let t=s-1;t>=1;t--)e|=1n<<8n*BigInt(t)+BigInt(i);for(let t=i+1;t<=6;t++)e|=1n<<8n*BigInt(s)+BigInt(t);for(let t=i-1;t>=1;t--)e|=1n<<8n*BigInt(s)+BigInt(t);return BigInt.asUintN(64,e)}GenerateRookAttacksFly(t,e){let s=0n;const i=Math.floor(t/8),a=t%8;for(let t=i+1;t<=7&&(s|=1n<<8n*BigInt(t)+BigInt(a),!(1n<<8n*BigInt(t)+BigInt(a)&e));t++);for(let t=i-1;t>=0&&(s|=1n<<8n*BigInt(t)+BigInt(a),!(1n<<8n*BigInt(t)+BigInt(a)&e));t--);for(let t=a+1;t<=7&&(s|=1n<<8n*BigInt(i)+BigInt(t),!(1n<<8n*BigInt(i)+BigInt(t)&e));t++);for(let t=a-1;t>=0&&(s|=1n<<8n*BigInt(i)+BigInt(t),!(1n<<8n*BigInt(i)+BigInt(t)&e));t--);return BigInt.asUintN(64,s)}EncodeMove(t,e,s){return(15&s)<<12|(63&t)<<6|63&e}MoveType(t){return t>>12&15}HasFlag(t,e){return 0!=(t>>12&e)}IsCapture(t){return 0!=(t>>12&4)}IsPromotion(t){return 0!=(t>>12&8)}MoveTo(t){return 63&t}MoveFrom(t){return t>>6&63}IsCastle(t){return 2===this.MoveType(t)||3===this.MoveType(t)}StringifyMove(e){const s=this.MoveFrom(e);let i=this.MoveTo(e);const a=this.MoveType(e);this.IsCastle(e)&&!this.isChess960&&(i=i>s?i-1:i+2);let o=`${t[s]}${t[i]}`;return this.HasFlag(e,8)&&(8!==a&&12!==a||(o+="n"),9!==a&&13!==a||(o+="b"),10!==a&&14!==a||(o+="r"),11!==a&&15!==a||(o+="q")),o}GenerateBishopAttacks(t,e){return t=BigInt.asUintN(64,(t&this.BishopMasks[e])*this.BishopMagicNumbers[e]),t>>=64n-this.BishopRelevantBits[e],this.BishopAttacks[e][Number(t)]}GenerateRookAttacks(t,e){return t=BigInt.asUintN(64,(t&this.RookMasks[e])*this.RookMagicNumbers[e]),t>>=64n-this.RookRelevantBits[e],this.RookAttacks[e][Number(t)]}GeneratePawnMoves(e=!1){const s=[],i=this.BoardState.SideToMove,a=this.BoardState.PiecesBB[0+6*i],o=~(this.BoardState.OccupanciesBB[0]|this.BoardState.OccupanciesBB[1]),n=this.BoardState.OccupanciesBB[1^i];let h=this.rankMasks[t.a3],r=8,B=9,l=7,c=~this.rankMasks[t.a8];if(1===i&&(h=this.rankMasks[t.a6],r=-8,B=-9,l=-7,c=~this.rankMasks[t.a1]),!e){let t=this.Shift(a,r)&o&c,e=this.Shift(t&h,r)&o;for(;t;){const e=this.GetLS1B(t);t=this.RemoveBit(t,e),s.push(this.EncodeMove(e+r,e,0))}for(;e;){const t=this.GetLS1B(e);e=this.RemoveBit(e,t),s.push(this.EncodeMove(t+2*r,t,0))}}let S=this.Shift(a,l)&n,d=this.Shift(a,B)&n;for(;S;){const e=this.GetLS1B(S);S=this.RemoveBit(S,e),0===i&&e<=t.h8||1===i&&e>=t.a1?s.push(this.EncodeMove(e+l,e,12),this.EncodeMove(e+l,e,13),this.EncodeMove(e+l,e,14),this.EncodeMove(e+l,e,15)):s.push(this.EncodeMove(e+l,e,4))}for(;d;){const e=this.GetLS1B(d);d=this.RemoveBit(d,e),0===i&&e<=t.h8||1===i&&e>=t.a1?s.push(this.EncodeMove(e+B,e,12),this.EncodeMove(e+B,e,13),this.EncodeMove(e+B,e,14),this.EncodeMove(e+B,e,15)):s.push(this.EncodeMove(e+B,e,4))}let P=this.Shift(a,r)&o&~c;for(;P;){const t=this.GetLS1B(P);P=this.RemoveBit(P,t),s.push(this.EncodeMove(t+r,t,8),this.EncodeMove(t+r,t,9),this.EncodeMove(t+r,t,10),this.EncodeMove(t+r,t,11))}if(this.BoardState.EnPassSq!==t.no_sq&&this.PawnAttacks[this.BoardState.EnPassSq+64*(1^this.BoardState.SideToMove)]&a){let t=this.Shift(a,l)&this.squareBB[this.BoardState.EnPassSq],e=this.Shift(a,B)&this.squareBB[this.BoardState.EnPassSq];for(;t;){const e=this.GetLS1B(t);t=this.RemoveBit(t,e),s.push(this.EncodeMove(e+l,e,5))}for(;e;){const t=this.GetLS1B(e);e=this.RemoveBit(e,t),s.push(this.EncodeMove(t+B,t,5))}}return s}GenerateMoves(e=!1){const s=[],i=this.BoardState.OccupanciesBB[1^this.BoardState.SideToMove],a=this.BoardState.OccupanciesBB[0]|this.BoardState.OccupanciesBB[1],o=~a;let n=this.BoardState.OccupanciesBB[this.BoardState.SideToMove]&~this.BoardState.PiecesBB[0+6*this.BoardState.SideToMove];for(s.push(...this.GeneratePawnMoves(e));n;){const t=this.GetLS1B(n);n=this.RemoveBit(n,t);let h=0n;switch(this.BoardState.Squares[t].Type){case 1:h=this.KnightAttacks[t];break;case 2:h=this.GenerateBishopAttacks(a,t);break;case 3:h=this.GenerateRookAttacks(a,t);break;case 4:h=this.GenerateBishopAttacks(a,t)|this.GenerateRookAttacks(a,t);break;case 5:h=this.KingAttacks[t];break;default:throw new Error("Invalid piece in move gen.")}if(!e){let e=h&o;for(;e;){const i=this.GetLS1B(e);e=this.RemoveBit(e,i),s.push(this.EncodeMove(t,i,0))}}let r=h&i;for(;r;){const e=this.GetLS1B(r);r=this.RemoveBit(r,e),s.push(this.EncodeMove(t,e,4))}}if(!e){const e=this.GetLS1B(this.BoardState.PiecesBB[5+6*this.BoardState.SideToMove]);this.IsSquareAttacked(e,1^this.BoardState.SideToMove)||(0===this.BoardState.SideToMove?(1&this.BoardState.CastlingRights&&0n===(this.BoardState.CastlingPaths[1]&a)&&!this.IsPathAttacked(this.betweenMasks[e][t.h1])&&s.push(this.EncodeMove(e,this.BoardState.CastlingRookSquares[1],2)),2&this.BoardState.CastlingRights&&0n===(this.BoardState.CastlingPaths[2]&a)&&!this.IsPathAttacked(this.betweenMasks[e][t.c1])&&s.push(this.EncodeMove(e,this.BoardState.CastlingRookSquares[2],3))):(4&this.BoardState.CastlingRights&&0n===(this.BoardState.CastlingPaths[4]&a)&&!this.IsPathAttacked(this.betweenMasks[e][t.h8])&&s.push(this.EncodeMove(e,this.BoardState.CastlingRookSquares[4],2)),8&this.BoardState.CastlingRights&&0n===(this.BoardState.CastlingPaths[8]&a)&&!this.IsPathAttacked(this.betweenMasks[e][t.c8])&&s.push(this.EncodeMove(e,this.BoardState.CastlingRookSquares[8],3))))}return s}ScoreMoves(t,e,s){let i=[];for(let a=0;a<t.length;a++){const o=t[a],n=this.MoveFrom(o),h=this.MoveTo(o);if(o===e)i.push({move:e,score:this.INFINITY});else if(this.IsCapture(o)){const t=this.BoardState.Squares[n],e=this.BoardState.Squares[h]??{Type:0,Color:0};i.push({move:o,score:this.MGPieceValue[e.Type]-t.Type+1e4})}else o===this.killerMoves[this.BoardState.Ply][0]?i.push({move:o,score:9e3}):o===this.killerMoves[this.BoardState.Ply][1]?i.push({move:o,score:8e3}):o===this.counterMoves[this.MoveFrom(s)][this.MoveTo(s)]?i.push({move:o,score:7e3}):i.push({move:o,score:this.historyMoves[this.BoardState.SideToMove][n][h]})}return i}NextMove(t,e){let s=e;for(let i=e;i<t.length;i++)t[i].score>t[s].score&&(s=i);const i=t[e];return t[e]=t[s],t[s]=i,t[e++]}AttacksToByColor(t,e){const s=this.BoardState.PiecesBB[0+6*e]&this.PawnAttacks[t+64*(1^e)],i=this.BoardState.PiecesBB[1+6*e]&this.KnightAttacks[t],a=this.BoardState.PiecesBB[5+6*e]&this.KingAttacks[t],o=this.BoardState.OccupanciesBB[0]|this.BoardState.OccupanciesBB[1];let n=this.BoardState.PiecesBB[2+6*e]|this.BoardState.PiecesBB[4+6*e];n&=this.GenerateBishopAttacks(o,t);let h=this.BoardState.PiecesBB[3+6*e]|this.BoardState.PiecesBB[4+6*e];return h&=this.GenerateRookAttacks(o,t),s|i|a|n|h}AttackedSquares(t,e){const s=this.BoardState.PiecesBB[0+6*t];let i=this.BoardState.OccupanciesBB[t]&~s,a=9,o=7;1===t&&(a=-9,o=-7);let n=this.Shift(s,a)|this.Shift(s,o);for(;i;){const t=this.GetLS1B(i);switch(i=this.RemoveBit(i,t),this.BoardState.Squares[t].Type){case 1:n|=this.KnightAttacks[t];break;case 2:n|=this.GenerateBishopAttacks(e,t);break;case 3:n|=this.GenerateRookAttacks(e,t);break;case 4:n|=this.GenerateBishopAttacks(e,t)|this.GenerateRookAttacks(e,t);break;case 5:n|=this.KingAttacks[t];break;default:throw new Error("Invalid piece in move gen.")}}return n}PlacePiece(t,e,s){this.BoardState.PiecesBB[t+6*e]=this.SetBit(this.BoardState.PiecesBB[t+6*e],s),this.BoardState.OccupanciesBB[e]=this.SetBit(this.BoardState.OccupanciesBB[e],s),this.BoardState.Squares[s]={Type:t,Color:e}}RemovePiece(t,e,s){this.BoardState.PiecesBB[t+6*e]=this.RemoveBit(this.BoardState.PiecesBB[t+6*e],s),this.BoardState.OccupanciesBB[e]=this.RemoveBit(this.BoardState.OccupanciesBB[e],s),this.BoardState.Squares[s]=void 0}MovePiece(t,e,s){const i=this.squareBB[e]|this.squareBB[s];this.BoardState.PiecesBB[t.Type+6*t.Color]^=i,this.BoardState.OccupanciesBB[t.Color]^=i,this.BoardState.Squares[e]=void 0,this.BoardState.Squares[s]=t}DoCastle(e,s,i){const a=i>s;let o=t.g1^56*e.Color,n=t.f1^56*e.Color;a||(o=t.c1^56*e.Color,n=t.d1^56*e.Color);const h=i;this.RemovePiece(3,e.Color,h),this.RemovePiece(e.Type,e.Color,s),this.PlacePiece(3,e.Color,n),this.PlacePiece(e.Type,e.Color,o),this.BoardState.Hash^=this.Zobrist.Pieces[e.Color][3][h]^this.Zobrist.Pieces[e.Color][3][n]^this.Zobrist.Pieces[e.Color][5][o]^this.Zobrist.Pieces[e.Color][5][s]}UndoCastle(e,s){const i=this.BoardState.SideToMove,a=s>e;let o=t.g1^56*i,n=t.f1^56*i;a||(o=t.c1^56*i,n=t.d1^56*i);const h=s;this.RemovePiece(3,i,n),this.RemovePiece(5,i,o),this.PlacePiece(3,i,h),this.PlacePiece(5,i,e)}MakeMove(e){const s=this.MoveFrom(e),i=this.MoveTo(e),a=this.MoveType(e),o=this.BoardState.Squares[s];let n=5===a?{Type:0,Color:1^this.BoardState.SideToMove}:this.BoardState.Squares[i];if(this.boardStates.push({CastlingRights:this.BoardState.CastlingRights,EnPassSq:this.BoardState.EnPassSq,Captured:n,Hash:this.BoardState.Hash,PawnHash:this.BoardState.PawnHash,HalfMoves:this.BoardState.HalfMoves,Phase:this.BoardState.Phase}),this.BoardState.Ply++,this.BoardState.HalfMoves++,this.BoardState.EnPassSq!==t.no_sq&&(this.BoardState.Hash^=this.Zobrist.EnPassant[this.BoardState.EnPassSq],this.BoardState.EnPassSq=t.no_sq),this.IsCastle(e))this.DoCastle(o,s,i);else{let t=0===o.Color?8:-8;if(void 0!==n){let e=i;5===a&&(e=i+t),this.RemovePiece(n.Type,n.Color,e),this.BoardState.HalfMoves=0,this.BoardState.Hash^=this.Zobrist.Pieces[n.Color][n.Type][e],this.BoardState.Phase+=this.PhaseValues[n.Type],0===n.Type&&(this.BoardState.PawnHash^=this.Zobrist.Pieces[n.Color][n.Type][e])}if(this.MovePiece(o,s,i),this.BoardState.Hash^=this.Zobrist.Pieces[o.Color][o.Type][s]^this.Zobrist.Pieces[o.Color][o.Type][i],0===o.Type)if(this.BoardState.HalfMoves=0,this.BoardState.PawnHash^=this.Zobrist.Pieces[o.Color][o.Type][s]^this.Zobrist.Pieces[o.Color][o.Type][i],this.HasFlag(e,8)){let t=0;switch(a){case 8:case 12:t=1;break;case 9:case 13:t=2;break;case 10:case 14:t=3;break;case 11:case 15:t=4}const e={Type:t,Color:o.Color};this.RemovePiece(o.Type,o.Color,i),this.PlacePiece(e.Type,e.Color,i),this.BoardState.Phase+=this.PhaseValues[0],this.BoardState.Phase-=this.PhaseValues[e.Type],this.BoardState.Hash^=this.Zobrist.Pieces[o.Color][o.Type][i]^this.Zobrist.Pieces[e.Color][e.Type][i],this.BoardState.PawnHash^=this.Zobrist.Pieces[o.Color][o.Type][i]}else 16==(i^s)&&(this.BoardState.EnPassSq=i+t,this.BoardState.Hash^=this.Zobrist.EnPassant[this.BoardState.EnPassSq])}return this.BoardState.Hash^=this.Zobrist.Castle[this.BoardState.CastlingRights],this.BoardState.CastlingRights&=this.BoardState.CastlingSquaresMask[s]&this.BoardState.CastlingSquaresMask[i],this.BoardState.Hash^=this.Zobrist.Castle[this.BoardState.CastlingRights],this.BoardState.SideToMove^=1,this.BoardState.Hash^=this.Zobrist.SideToMove,this.BoardHistory[this.BoardHistory.length]=this.BoardState.Hash,!this.IsSquareAttacked(this.GetLS1B(this.BoardState.PiecesBB[5+6*(1^this.BoardState.SideToMove)]),this.BoardState.SideToMove)}UnmakeMove(t){const e=this.boardStates.pop();this.BoardState.Ply--,this.BoardHistory.pop(),this.BoardState.CastlingRights=e.CastlingRights,this.BoardState.EnPassSq=e.EnPassSq,this.BoardState.HalfMoves=e.HalfMoves,this.BoardState.Phase=e.Phase,this.BoardState.SideToMove^=1;const s=this.MoveFrom(t),i=this.MoveTo(t),a=this.BoardState.Squares[i];if(this.IsCastle(t))this.UndoCastle(s,i);else if(this.HasFlag(t,8))this.RemovePiece(a.Type,a.Color,i),this.PlacePiece(0,a.Color,s),e.Captured&&this.PlacePiece(e.Captured.Type,e.Captured.Color,i);else if(this.MovePiece(a,i,s),e.Captured){let s=i,o=e.Captured;5===this.MoveType(t)&&(s=0===a.Color?i+8:i-8),this.PlacePiece(o.Type,o.Color,s)}this.BoardState.Hash=e.Hash,this.BoardState.PawnHash=e.PawnHash}MakeNullMove(){this.boardStates.push({CastlingRights:this.BoardState.CastlingRights,EnPassSq:this.BoardState.EnPassSq,Hash:this.BoardState.Hash,HalfMoves:this.BoardState.HalfMoves,PawnHash:this.BoardState.PawnHash,Phase:this.BoardState.Phase}),this.BoardState.EnPassSq!==t.no_sq&&(this.BoardState.Hash^=this.Zobrist.EnPassant[this.BoardState.EnPassSq],this.BoardState.EnPassSq=t.no_sq),this.BoardState.HalfMoves=0,this.BoardState.SideToMove^=1,this.BoardState.Hash^=this.Zobrist.SideToMove,this.BoardState.Ply++}UnmakeNullMove(){const t=this.boardStates.pop();this.BoardState.CastlingRights=t.CastlingRights,this.BoardState.EnPassSq=t.EnPassSq,this.BoardState.HalfMoves=t.HalfMoves,this.BoardState.SideToMove^=1,this.BoardState.Hash=t.Hash,this.BoardState.PawnHash=t.PawnHash,this.BoardState.Ply--,this.BoardState.Phase=t.Phase}IsSquareAttacked(t,e){if(this.PawnAttacks[t+64*(1^e)]&this.BoardState.PiecesBB[0+6*e])return!0;if(this.KnightAttacks[t]&this.BoardState.PiecesBB[1+6*e])return!0;const s=this.BoardState.PiecesBB[4+6*e],i=this.BoardState.OccupanciesBB[0]|this.BoardState.OccupanciesBB[1],a=this.BoardState.PiecesBB[2+6*e]|s;if(this.attackRays[0][t]&a&&this.GenerateBishopAttacks(i,t)&a)return!0;const o=this.BoardState.PiecesBB[3+6*e]|s;return!!(this.attackRays[1][t]&o&&this.GenerateRookAttacks(i,t)&o)||!!(this.KingAttacks[t]&this.BoardState.PiecesBB[5+6*e])}IsPathAttacked(t){let e=!1;for(;t;){const s=this.GetLS1B(t);if(t=this.RemoveBit(t,s),this.IsSquareAttacked(s,1^this.BoardState.SideToMove)){e=!0;break}}return e}ResizeTranspositionTable(t){this.TranspositionTables=Array(1024*t*1024/16).fill(null),this.TTSize=BigInt(1024*t*1024/16),this.TTUsed=0}StoreEntry(t,e,s,i,a){const o=Number(t%this.TTSize);null===this.TranspositionTables[o]&&this.TTUsed++,this.TranspositionTables[o]={Hash:t,Move:s,Depth:e,Score:i,Flag:a}}GetEntry(t){const e=this.TranspositionTables[Number(t%this.TTSize)];return e&&e.Hash!==t?null:e}StorePawnHash(t,e,s,i){const a=Number(t%this.PawnTableSize);this.PawnTable[a]={Hash:t,Mg:e,Eg:s,SideToMove:i}}GetPawnEntry(t){const e=this.PawnTable[Number(t%this.PawnTableSize)];return(!e||e.Hash===t)&&e}Evaluate(){let e=[0,0],s=[0,0],i=this.BoardState.Phase,a=(this.BoardState.OccupanciesBB[0]|this.BoardState.OccupanciesBB[1])&~(this.BoardState.PiecesBB[0]|this.BoardState.PiecesBB[6]);const o=[0,0];if(0n===(this.BoardState.PiecesBB[0]|this.BoardState.PiecesBB[6])){if(this.IsDraw())return 0;let e=[t.no_sq,t.no_sq];for(;a;){let t=this.GetLS1B(a);a=this.RemoveBit(a,t);const i=this.BoardState.Squares[t];s[i.Color]+=this.EGPieceValue[i.Type],5===i.Type&&(e[i.Color]=t)}const i=this.distanceBetween[e[0]][e[1]];return Math.abs(s[0]-s[1])>10?(s[0]>s[1]?s[1]-=50*this.CenterManhattanDistance[e[1]]:s[0]-=50*this.CenterManhattanDistance[e[0]],s[this.BoardState.SideToMove]-s[1^this.BoardState.SideToMove]-35*(7-i)):0}const n=this.EvaluatePawns();for(;a;){let i=this.GetLS1B(a);const n=i;a=this.RemoveBit(a,i);const h=this.BoardState.Squares[i];switch(1===h.Color&&(i^=56),h.Type){case 1:this.PawnAttacks[n+64*(1^h.Color)]&this.BoardState.PiecesBB[0+6*h.Color]&&!(this.PawnAttacks[n+64*h.Color]&this.BoardState.PiecesBB[0+6*(1^h.Color)])&&(e[h.Color]+=this.MGKnightOutpost,s[h.Color]+=this.EGKnightOutpost);break;case 2:if(o[h.Color]++,this.isChess960&&(i===t.a1||i===t.h1)){let t=0==(7&i)?1n<<49n:1n<<54n;1===h.Color&&(t>>=40n),0n!==(t&this.BoardState.PiecesBB[0+6*h.Color])&&(e[h.Color]-=this.MGCorneredBishopPenalty,s[h.Color]-=this.EGCorneredBishopPenalty)}break;case 3:0n===(this.fileMasks[n]&this.BoardState.PiecesBB[0+6*h.Color])&&(0n===(this.fileMasks[n]&this.BoardState.PiecesBB[0+6*(1^h.Color)])?e[h.Color]+=this.MGRookOpenFileBonus:e[h.Color]+=this.MGRookSemiOpenFileBonus)}e[h.Color]+=this.PST[0][h.Type][i]+this.MGPieceValue[h.Type],s[h.Color]+=this.PST[1][h.Type][i]+this.EGPieceValue[h.Type]}o[0]>=2&&(e[0]+=this.MGBishopPair,s[0]+=this.EGBishopPair),o[1]>=2&&(e[1]+=this.MGBishopPair,s[1]+=this.EGBishopPair);const h=e[this.BoardState.SideToMove]-e[1^this.BoardState.SideToMove]+n.opening,r=s[this.BoardState.SideToMove]-s[1^this.BoardState.SideToMove]+n.endgame;return i=(256*i+this.PhaseTotal/2)/this.PhaseTotal|0,(h*(256-i)+r*i)/256|0}EvaluatePawns(){const t=this.GetPawnEntry(this.BoardState.PawnHash);if(t)return t.SideToMove!==this.BoardState.SideToMove?{opening:-1*t.Mg,endgame:-1*t.Eg}:{opening:t.Mg,endgame:t.Eg};let e=[0,0],s=[0,0],i=this.BoardState.PiecesBB[0]|this.BoardState.PiecesBB[6];for(;i;){let t=this.GetLS1B(i);const a=t;i=this.RemoveBit(i,t);const o=this.BoardState.Squares[t],n=0===o.Color?8-(t>>3):1+(t>>3),h=0===o.Color?8:-8;1===o.Color&&(t^=56),this.Shift(this.squareBB[a],1)&this.BoardState.PiecesBB[0+6*o.Color]&&(s[o.Color]+=this.PawnDuoMulti[n-1]),this.PawnAttacks[a+64*(1^o.Color)]&this.BoardState.PiecesBB[0+6*o.Color]&&(s[o.Color]+=this.PawnSupportMulti[n-1]),0n!==(this.Shift(this.squareBB[a],-1*h)&this.BoardState.PiecesBB[0+6*o.Color])&&(e[o.Color]-=this.MGDoubledPawn,s[o.Color]-=this.EGDoubledPawn),0n===(this.Fill(-1*h,a)&this.BoardState.PiecesBB[0+6*o.Color])&&0n===(this.passedMasks[o.Color][t]&this.BoardState.PiecesBB[0+6*(1^o.Color)])&&(e[o.Color]+=this.MGPassedPawnRank[n-1],s[o.Color]+=this.EGPassedPawnRank[n-1]),0n===(this.isolatedMasks[a]&this.BoardState.PiecesBB[0+6*o.Color])&&(e[o.Color]-=this.MGIsolatedPawn,s[o.Color]-=this.EGIsolatedPawn),e[o.Color]+=this.PST[0][0][t]+this.MGPieceValue[0],s[o.Color]+=this.PST[1][0][t]+this.EGPieceValue[0]}const a=e[this.BoardState.SideToMove]-e[1^this.BoardState.SideToMove],o=s[this.BoardState.SideToMove]-s[1^this.BoardState.SideToMove];return this.StorePawnHash(this.BoardState.PawnHash,a,o,this.BoardState.SideToMove),{opening:a,endgame:o}}IsDraw(){if((this.BoardState.PiecesBB[5]|this.BoardState.PiecesBB[11])==(this.BoardState.OccupanciesBB[0]|this.BoardState.OccupanciesBB[1]))return!0;const t=this.CountBits(this.BoardState.PiecesBB[0])+this.CountBits(this.BoardState.PiecesBB[6]),e=this.CountBits(this.BoardState.PiecesBB[1]),s=this.CountBits(this.BoardState.PiecesBB[7]),i=this.CountBits(this.BoardState.PiecesBB[2]),a=this.CountBits(this.BoardState.PiecesBB[8]),o=e+s+i+a;if(this.CountBits(this.BoardState.PiecesBB[3])+this.CountBits(this.BoardState.PiecesBB[9])+(this.CountBits(this.BoardState.PiecesBB[4])+this.CountBits(this.BoardState.PiecesBB[10]))+t===0){if(1===o)return!0;if(2===o){if(1===e&&1===s)return!0;if(1===i&&1===a)return!0}}return!1}GetPv(){let t="";for(let e=0;e<this.pvLength[0];e++)t+=this.StringifyMove(this.pvArray[0][e])+" ";return t}FormatScore(t){return t<-this.MATE?"mate "+(-this.INFINITY-t)/2:t>this.MATE?"mate "+(this.INFINITY-t+1)/2:"cp "+(0|t)}UpdatePv(t){this.pvArray[this.BoardState.Ply][this.BoardState.Ply]=t;for(let t=this.BoardState.Ply+1;t<this.pvLength[this.BoardState.Ply+1];t++)this.pvArray[this.BoardState.Ply][t]=this.pvArray[this.BoardState.Ply+1][t];this.pvLength[this.BoardState.Ply]=this.pvLength[this.BoardState.Ply+1]}Search(e){this.StartTimer();let s=-this.INFINITY,i=this.INFINITY,a=-this.INFINITY;const o=Date.now();this.pvArray=Array(this.MAXPLY).fill(0).map((()=>Array(this.MAXPLY).fill(0))),this.pvLength=Array(this.MAXPLY).fill(0),this.nodesSearched=0,this.BoardState.Ply=0;for(let e=0;e<=1;e++)for(let s=t.a8;s<=t.h1;s++)for(let i=t.a8;i<=t.h1;i++)this.historyMoves[e][s][i]/=2;for(let t=1;t<=e;t++){let e=10;for(t>=5&&(s=Math.max(a-e,-this.INFINITY),i=Math.min(a+e,this.INFINITY));!this.Timer.stop;){if(a=this.NegaScout(s,i,t,0,!0),a<=s)s=Math.max(a-e,-this.INFINITY),i=(s+i)/2;else{if(!(a>=i))break;i=Math.min(a+e,this.INFINITY)}e+=e/2}if(this.Timer.stop)break;const n=Date.now();console.log(`info depth ${t} score ${this.FormatScore(a)} nodes ${this.nodesSearched} nps ${1e3*this.nodesSearched/(n-o)|0} hashfull ${1e3*this.TTUsed/Number(this.TTSize)|0} time ${n-o} pv ${this.GetPv()}`)}console.log(`bestmove ${this.StringifyMove(this.pvArray[0][0])}`)}NegaScout(t,e,s,i,a){if(this.nodesSearched%1e3==0&&(this.CheckTime(),this.Timer.stop))return this.ABORTEDSCORE;if(this.nodesSearched++,this.BoardState.Ply>=this.MAXPLY)return 0;if(this.pvLength[this.BoardState.Ply]=this.BoardState.Ply,this.BoardState.Ply>0&&(this.IsRepetition()||this.BoardState.HalfMoves>100))return 0;if(s<=0)return this.Quiescence(t,e,i);const o=e-t>1;let n=1,h=-this.INFINITY,r=0,B=e,l=0,c=0,S=[],d=-this.INFINITY;const P=this.GetEntry(this.BoardState.Hash);if(!o&&P&&P.Depth>=s&&(0===P.Flag||2===P.Flag&&P.Score>=e||1===P.Flag&&P.Score<=t))return P.Score;P&&(l=P.Move);let p=-this.INFINITY;const g=this.IsSquareAttacked(this.GetLS1B(this.BoardState.PiecesBB[5+6*this.BoardState.SideToMove]),1^this.BoardState.SideToMove);if(0===l&&s>=3&&(s-=1),!g&&!o){if(p=this.Evaluate(),s<=5&&p-60*s>=e&&Math.abs(p)<this.INFINITY-this.BoardState.Ply)return p;if(a&&p>=e&&0n!==(this.BoardState.OccupanciesBB[this.BoardState.SideToMove]^this.BoardState.PiecesBB[5+6*this.BoardState.SideToMove]^this.BoardState.PiecesBB[0+6*this.BoardState.SideToMove])){this.MakeNullMove();const t=3+Math.floor(s/5);let i=-this.NegaScout(-e,1-e,s-1-t,0,!1);if(this.UnmakeNullMove(),i>=e)return Math.abs(i)>this.INFINITY-this.BoardState.Ply?e:i}}if((t=Math.max(-this.INFINITY+this.BoardState.Ply,t))>=(e=Math.min(this.INFINITY-this.BoardState.Ply,e)))return t;const u=this.ScoreMoves(this.GenerateMoves(),l,i);for(let a=0;a<u.length;a++){const l=this.NextMove(u,a).move;if(!(o||g||this.IsCapture(l)||this.IsPromotion(l))){if(s<=10&&c>0&&p+110*s<t)continue;if(s<=4&&c>8*s)continue}if(!this.MakeMove(l)){this.UnmakeMove(l);continue}c++;let P=g?1:0;if(s>=3&&a>4){let e=1/(4/s)|0;if(this.IsCapture(l)||this.IsPromotion(l)||e++,e=Math.max(0,e),d=-this.NegaScout(-t-1,-t,s-1-e+P,l,!0),d<=t){this.UnmakeMove(l);continue}}if(d=-this.NegaScout(-B,-t,s-1+P,l,!0),d>t&&d<e&&a>1&&(d=-this.NegaScout(-e,-t,s-1+P,l,!0)),this.UnmakeMove(l),this.Timer.stop)return this.ABORTEDSCORE;if(d>h&&(h=d,r=l),d>t&&(t=d,n=0,this.UpdatePv(l),this.Timer.extended=s>1&&d+35<this.bestMoveScore.score,this.bestMoveScore={move:r,score:h}),t>=e){if(n=2,!this.IsCapture(l)){this.killerMoves[this.BoardState.Ply][1]=this.killerMoves[this.BoardState.Ply][0],this.killerMoves[this.BoardState.Ply][0]=l,this.counterMoves[this.MoveFrom(i)][this.MoveTo(i)]=l,this.historyMoves[this.BoardState.SideToMove][this.MoveFrom(l)][this.MoveTo(l)]+=s*s;for(let t=0;t<S.length;t++)this.historyMoves[this.BoardState.SideToMove][this.MoveFrom(S[t])][this.MoveTo(S[t])]+=-s*s}break}this.IsCapture(l)||S.push(l),B=t+1}return 0===c?g?-this.INFINITY+this.BoardState.Ply:0:(this.StoreEntry(this.BoardState.Hash,s,r,h,n),h)}Quiescence(t,e,s){if(this.nodesSearched%1e3==0&&(this.CheckTime(),this.Timer.stop))return this.ABORTEDSCORE;if(this.nodesSearched++,this.BoardState.Ply>=this.MAXPLY)return 0;const i=e-t>1;let a=1,o=0;const n=this.GetEntry(this.BoardState.Hash);if(!i&&n&&(0===n.Flag||2===n.Flag&&n.Score>=e||1===n.Flag&&n.Score<=t))return n.Score;n&&(o=n.Move);const h=this.Evaluate();if(h>=e)return h;h>t&&(t=h);let r=h,B=0;const l=this.ScoreMoves(this.GenerateMoves(!0),o,s);for(let s=0;s<l.length;s++){const i=this.NextMove(l,s).move;if(h+150+this.MGPieceValue[4]<t)continue;if(this.See(i)<0)continue;if(!this.MakeMove(i)){this.UnmakeMove(i);continue}let o=-this.Quiescence(-e,-t,i);if(this.UnmakeMove(i),o>r&&(r=o,B=i),o>=e){a=2;break}o>t&&(t=o,a=0)}return this.StoreEntry(this.BoardState.Hash,0,B,r,a),r}See(t){const e=this.MoveFrom(t),s=this.MoveTo(t),i=this.BoardState.Squares[e];let a=this.BoardState.Squares[s]?.Type,o=1^this.BoardState.SideToMove;const n=this.BoardState.OccupanciesBB[0]|this.BoardState.OccupanciesBB[1];if(void 0===i||void 0===a)return 0;const h=this.BoardState.PiecesBB[1]|this.BoardState.PiecesBB[7],r=this.BoardState.PiecesBB[2]|this.BoardState.PiecesBB[8],B=this.BoardState.PiecesBB[3]|this.BoardState.PiecesBB[9],l=this.BoardState.PiecesBB[4]|this.BoardState.PiecesBB[10],c=r|l,S=B|l,d=this.BoardState.PiecesBB[0]|this.BoardState.PiecesBB[6]|r|B|l,P=[];let p=0,g=this.squareBB[e],u=this.AttacksTo(s,n,h,c,S),M=0n;for(P[p]=this.MGPieceValue[a];g&&(p++,P[p]=this.MGPieceValue[i.Type]-P[p-1],!(Math.max(-P[p-1],P[p])<0));){u^=g,M|=g,g&d&&(u|=(c&this.GenerateBishopAttacks(n,s)|S&this.GenerateRookAttacks(n,s))&~M);const{bitboard:t,piece:e}=this.GetLeastValuablePiece(u,o,a);g=t,a=e,o^=1}for(;--p;)P[p-1]=-Math.max(-P[p-1],P[p]);return P[0]}AttacksTo(t,e,s,i,a){const o=this.BoardState.PiecesBB[0]&this.PawnAttacks[t+64]|this.BoardState.PiecesBB[6]&this.PawnAttacks[t],n=(this.BoardState.PiecesBB[5]|this.BoardState.PiecesBB[11])&this.KingAttacks[t];return i&=this.GenerateBishopAttacks(e,t),a&=this.GenerateRookAttacks(e,t),o|s&this.KnightAttacks[t]|n|i|a}GetLeastValuablePiece(t,e,s){for(s=0;s<=5;s++){let i=t&this.BoardState.PiecesBB[s+6*e];if(i)return{bitboard:i&-i,piece:s}}return{bitboard:0n,piece:0}}IsRepetition(){for(let t=this.boardStates.length-this.BoardState.HalfMoves;t<this.boardStates.length-1;t++)if(this.boardStates[t]?.Hash===this.BoardState.Hash)return!0;return!1}LoadFEN(e){this.BoardState.PiecesBB=new BigUint64Array(12),this.BoardState.OccupanciesBB=new BigUint64Array(2),this.BoardState.CastlingRights=0,this.BoardState.Squares=new Array(64).fill(void 0),this.BoardState.EnPassSq=t.no_sq,this.BoardState.Phase=this.PhaseTotal,this.BoardState.CastlingSquaresMask=new Array(64).fill(15);const s=e.split(" ")[0].split("");let i=0;for(let t=0;t<s.length;t++){const e=s[t];switch(e.toLowerCase()){case"p":case"n":case"b":case"r":case"q":case"k":{const t=this.CharToPiece.get(e);this.PlacePiece(t.Type,t.Color,i),this.BoardState.Phase-=this.PhaseValues[t.Type],i++;break}case"1":case"2":case"3":case"4":case"4":case"5":case"6":case"7":case"8":i+=parseInt(e);break;case"/":break;default:throw new Error(`Unable to parse FEN character: ${e}`)}}this.BoardState.SideToMove="w"===e.split(" ")[1]?0:1;const a=e.split(" ")[2].split("");for(const e of a){const s=e.toUpperCase()===e?0:1,i=this.GetLS1B(this.BoardState.PiecesBB[5+6*s]);if(this.BoardState.CastlingSquaresMask[i]=0===s?12:3,"K"===e.toUpperCase()){const e=this.BoardState.Squares.findIndex(((t,e)=>t&&3===t.Type&&t.Color===s&&e>i));0===s?(this.BoardState.CastlingRights|=1,this.BoardState.CastlingPaths[1]=(this.betweenMasks[i][t.g1]|this.betweenMasks[e][t.f1])&~(this.BoardState.PiecesBB[5+6*s]|this.SetBit(0n,e)),this.BoardState.CastlingRookSquares[1]=e,this.BoardState.CastlingSquaresMask[e]=14):(this.BoardState.CastlingRights|=4,this.BoardState.CastlingPaths[4]=(this.betweenMasks[i][t.g8]|this.betweenMasks[e][t.f8])&~(this.BoardState.PiecesBB[5+6*s]|this.SetBit(0n,e)),this.BoardState.CastlingRookSquares[4]=e,this.BoardState.CastlingSquaresMask[e]=11)}else if("Q"===e.toUpperCase()){const e=this.BoardState.Squares.findIndex(((t,e)=>t&&3===t.Type&&t.Color===s&&e<i));0===s?(this.BoardState.CastlingRights|=2,this.BoardState.CastlingPaths[2]=(this.betweenMasks[i][t.c1]|this.betweenMasks[e][t.d1])&~(this.BoardState.PiecesBB[5+6*s]|this.SetBit(0n,e)),this.BoardState.CastlingRookSquares[2]=e,this.BoardState.CastlingSquaresMask[e]=13):(this.BoardState.CastlingRights|=8,this.BoardState.CastlingPaths[8]=(this.betweenMasks[i][t.c8]|this.betweenMasks[e][t.d8])&~(this.BoardState.PiecesBB[5+6*s]|this.SetBit(0n,e)),this.BoardState.CastlingRookSquares[8]=e,this.BoardState.CastlingSquaresMask[e]=7)}else if(e.toUpperCase()>="A"&&e.toUpperCase()<="H")if(e.toUpperCase().charCodeAt(0)-65>(7&i)){const e=this.BoardState.Squares.findIndex(((t,e)=>t&&3===t.Type&&t.Color===s&&e>i));0===s?(this.BoardState.CastlingRights|=1,this.BoardState.CastlingPaths[1]=(this.betweenMasks[i][t.g1]|this.betweenMasks[e][t.f1]|this.squareBB[t.g1]|this.squareBB[t.f1])&~(this.BoardState.PiecesBB[5+6*s]|this.SetBit(0n,e)),this.BoardState.CastlingRookSquares[1]=e,this.BoardState.CastlingSquaresMask[e]=14):(this.BoardState.CastlingRights|=4,this.BoardState.CastlingPaths[4]=(this.betweenMasks[i][t.g8]|this.betweenMasks[e][t.f8]|this.squareBB[t.g8]|this.squareBB[t.f8])&~(this.BoardState.PiecesBB[5+6*s]|this.SetBit(0n,e)),this.BoardState.CastlingRookSquares[4]=e,this.BoardState.CastlingSquaresMask[e]=11)}else if(0===s){const e=this.BoardState.Squares.findIndex(((t,e)=>t&&3===t.Type&&t.Color===s&&e>=56&&e<i));this.BoardState.CastlingRights|=2,this.BoardState.CastlingPaths[2]=(this.betweenMasks[i][t.c1]|this.betweenMasks[e][t.d1]|this.squareBB[t.c1]|this.squareBB[t.d1])&~(this.BoardState.PiecesBB[5+6*s]|this.SetBit(0n,e)),this.BoardState.CastlingRookSquares[2]=e,this.BoardState.CastlingSquaresMask[e]=13}else{const e=this.BoardState.Squares.findIndex(((t,e)=>t&&3===t.Type&&t.Color===s&&e<i));this.BoardState.CastlingRights|=8,this.BoardState.CastlingPaths[8]=(this.betweenMasks[i][t.c8]|this.betweenMasks[e][t.d8]|this.squareBB[t.c8]|this.squareBB[t.d8])&~(this.BoardState.PiecesBB[5+6*s]|this.SetBit(0n,e)),this.BoardState.CastlingRookSquares[8]=e,this.BoardState.CastlingSquaresMask[e]=7}}const o=e.split(" ")[3];if("-"!==o){const t="abcdefgh".indexOf(o.split("")[0]),e=8*(8-parseInt(o[1],10))+t;this.BoardState.EnPassSq=e}this.BoardState.Ply=2*parseInt(e.split(" ")[5])||0,1===this.BoardState.SideToMove&&(this.BoardState.Ply--,this.BoardState.Ply<0&&(this.BoardState.Ply=1)),this.BoardState.HalfMoves=parseInt(e.split(" ")[4])||0;const{hash:n,pawnHash:h}=this.GenerateHashes();this.BoardState.Hash=n,this.BoardState.PawnHash=h}GenerateFEN(){let e="";for(let t=0;t<=7;t++){let s=0;for(let i=0;i<=7;i++){const a=8*t+i,o=this.BoardState.Squares[a];if(void 0===o){s++;continue}s>0&&(e+=s.toString(),s=0);let n=this.PieceToChar.get(o.Type);1===o.Color&&(n=n.toLowerCase()),e+=n}s>0&&(e+=s.toString()),t>=0&&7!==t&&(e+="/")}if(0===this.BoardState.SideToMove?e+=" w ":e+=" b ",0===this.BoardState.CastlingRights&&(e+="-"),0!=(1&this.BoardState.CastlingRights)&&(e+="K"),0!=(2&this.BoardState.CastlingRights)&&(e+="Q"),0!=(4&this.BoardState.CastlingRights)&&(e+="k"),0!=(8&this.BoardState.CastlingRights)&&(e+="q"),e+=" ",this.BoardState.EnPassSq===t.no_sq)e+="-";else{const t=(56^this.BoardState.EnPassSq)/8|0,s=(56^this.BoardState.EnPassSq)%8;e+=`${String.fromCharCode(s+"a".charCodeAt(0))}${t+1}`}return e+=" "+this.BoardState.HalfMoves.toString(),e}PrintBitboard(t){for(let e=0;e<8;e++){let s="";for(let i=0;i<8;i++){const a=8*e+i;i||(s+=8-e+"  "),s+=" "+(this.GetBit(t,a)?"1":"0")}console.log(`${s} \r\n`)}console.log("\r\n    a b c d e f g h"),console.log(`    Bitboard: ${t}`)}PrintBoard(){const e=[["♙","♘","♗","♖","♕","♔"],["♟︎","♞","♝","♜","♛","♚"]];for(let t=0;t<8;t++){let s="";for(let i=0;i<8;i++){let a=8*t+i,o=this.BoardState.Squares[a]??null;i||(s+=8-t+" "),s+=o?` ${e[o.Color][o.Type]}`:" . "}console.log(`${s} \r\n`)}console.log("\r\n   a  b  c  d  e  f  g  h"),console.log("Side to move: "+(0===this.BoardState.SideToMove?"white":"black")),console.log(`En passant: ${this.BoardState.EnPassSq!==t.no_sq?t[this.BoardState.EnPassSq]:"no"}`),console.log(`Castling rights: ${1&this.BoardState.CastlingRights?"K":"-"}${2&this.BoardState.CastlingRights?"Q":"-"}${4&this.BoardState.CastlingRights?"k":"-"}${8&this.BoardState.CastlingRights?"q":"-"}`),console.log(`Plies: ${this.BoardState.Ply}`)}StartTimer(){let t=0;if(this.Timer.stop=!1,this.Timer.extended=!1,-1!==this.Timer.timeleft||-1!==this.Timer.movetime){if(0!==this.Timer.movestogo){const e=Math.min(Math.max(this.Timer.movestogo,2),30);t=this.Timer.timeleft/e}else if(-1!==this.Timer.movetime)t=this.Timer.movetime;else{let e=25;this.BoardState.Ply<=20&&(e=45-this.BoardState.Ply),t=this.Timer.timeleft/e+this.Timer.increment/2}t>=this.Timer.timeleft&&(t-=this.Timer.increment),t<=0&&(t=this.Timer.increment-1),this.Timer.startTime=Date.now(),this.Timer.stopTime=this.Timer.startTime+t}}CheckTime(){if(this.Timer.stop||-1!==this.Timer.timeleft||-1!==this.Timer.movetime)return Date.now()>this.Timer.stopTime?-1!==this.Timer.movetime?void(this.Timer.stop=!0):this.Timer.extended?Date.now()-this.Timer.startTime>=.6*this.Timer.timeleft?void(this.Timer.stop=!0):void 0:void(this.Timer.stop=!0):void(Date.now()>this.Timer.stopTime&&(!this.Timer.extended||Date.now()-this.Timer.startTime>=.75*this.Timer.timeleft)&&(this.Timer.stop=!0))}ParseUCIPosition(t){const e=t.split(" ").slice(1).join(" ");e.startsWith("fen")?this.LoadFEN(e.split(" ").slice(1).join(" ")):this.LoadFEN(i.positions.start);const s=e.split("moves ").slice(1).join(" ").split(" ").filter((t=>""!=t));for(let e=0;e<s.length;e++){const i=this.ParseUCIMove(s[e]);if(!i){console.error("Unable to parse UCI command"),console.log(`Command: ${t}`),console.log(`Invalid move: ${s[e]}`);break}this.MakeMove(i)}}ParseUCIMove(e){const s=parseInt(e.charAt(0),36)-10,i=8*(7-(parseInt(e.charAt(1))-1))+s,a=parseInt(e.charAt(2),36)-10;let o=8*(7-(parseInt(e.charAt(3))-1))+a;const n=this.BoardState.Squares[i];let h=0;if(5===e.length){const t=e.charAt(4);"n"===t?h=8:"b"===t?h=9:"r"===t?h=10:"q"===t&&(h=11)}if(5===n.Type){const s=o>i;this.isChess960||"e1g1"!==e&&"e1c1"!==e&&"e8g8"!==e&&"e8c8"!==e?(o===this.BoardState.CastlingRookSquares[1]&&1&this.BoardState.CastlingRights||o===this.BoardState.CastlingRookSquares[4]&&4&this.BoardState.CastlingRights||o===this.BoardState.CastlingRookSquares[2]&&2&this.BoardState.CastlingRights||o===this.BoardState.CastlingRookSquares[8]&&8&this.BoardState.CastlingRights)&&(h=s?2:3):(o=(s?t.h1:t.a1)^56*n.Color,h=s?2:3)}else o===this.BoardState.EnPassSq&&0===n.Type&&(h=5);return this.EncodeMove(i,o,h)}ParseUCIGo(t){const e=t.split(" "),s=0===this.BoardState.SideToMove?"w":"b";let i=-1,a=0,o=0,n=-1,h=this.MAXPLY;for(let t=0;t<e.length;t++){const r=e[t];r===s+"time"?i=parseInt(e[t+1]):r===s+"inc"?a=parseInt(e[t+1]):"movestogo"===r?o=parseInt(e[t+1]):"depth"===r?h=Math.min(parseInt(e[t+1]),this.MAXPLY):"movetime"===r&&(n=parseInt(e[t+1]))}return this.Timer.timeleft=i,this.Timer.increment=a,this.Timer.depth=h,this.Timer.movestogo=o,this.Timer.movetime=n,this.Search(h)}Perft(t,e=!1){this.totalNodes=0;const s=performance.now(),i=this.GenerateMoves();for(let s=0;s<i.length;s++){const a=i[s];if(this.MakeMove(a)){let s=this.PerftDriver(t-1);e&&console.log(`${this.StringifyMove(a)}: ${s}`)}this.UnmakeMove(a)}const a=performance.now();return e&&console.log(`Nodes: ${this.totalNodes.toLocaleString()}. nps: ${Math.round(1e3*this.totalNodes/(a-s)).toLocaleString()}. Total time taken: ${a-s} ms`),this.totalNodes}PerftDriver(t){let e=0;if(0===t)return this.totalNodes++,1;const s=this.GenerateMoves();for(let i=0;i<s.length;i++){const a=s[i];this.MakeMove(a)&&(e+=this.PerftDriver(t-1)),this.UnmakeMove(a)}return e}}i.positions={empty:"8/8/8/8/8/8/8/8 b - - ",start:"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",kiwipete:"r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq -",pos3:"8/2p5/3p4/KP5r/1R3p1k/8/4P1P1/8 w - -",pos4w:"r3k2r/Pppp1ppp/1b3nbN/nP6/BBP1P3/q4N2/Pp1P2PP/R2Q1RK1 w kq - 0 1",pos4b:"r2q1rk1/pP1p2pp/Q4n2/bbp1p3/Np6/1B3NBn/pPPP1PPP/R3K2R b KQ - 0 1",pos5:"rnbq1k1r/pp1Pbppp/2p5/8/2B5/8/PPP1NnPP/RNBQK2R w KQ - 1 8",pos6:"r4rk1/1pp1qppp/p1np1n2/2b1p1B1/2B1P1b1/P1NP1N2/1PP1QPPP/R4RK1 w - - 0 10"};const a=i;Engine=s.default})();